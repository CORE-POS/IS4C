<html>
<head><title>Scanning UPCs</title>
</head>
<body>
The UPC <a href="howto-parse.html">parser module</a> is currently
hard to trace through and should probably be more flexible. I think
it should [eventually] be modular in three ways: handle special
store-specific UPCs so they don't have to be hard-coded, allow 
discounts to be calculated differently by location, and allow
pricing methods to vary by location.
<hr />
<h3>Special UPCs</h3>
This collection of classes handles UPCs that aren't actually 
products. For example, at WFC I use UPC prefix "4" on barcoded
member cards and custom coupons; someone else may use the prefix
differently or just not need that code enabled. 
<p />
<i>Note: Special UPCs cannot exist in the products table or they
will be treated like normal items</i>
<p />
All Special UPC object should subclass SpecialUPC (lib/Scanning/SpecialUPC.php)
and implement two methods:
<ul>
<li>is_special(string upc) - return true is the module handles this upc, false
otherwise</li>
<li>handle(string upc, array json) - perform whatever operations the
upc should trigger. handle() should return a json array with the same
formatting as a parser object (<a href="howto-parse.html">Reference</a>).
The json argument passed in will have all the required fields; handle()
just needs to make updates.</li>
</ul>
<h3>Example</h3>
For used to at some point and was still hardcoded in)
<pre>
class WackyPLU extends SpecialUPC {

	function is_special($upc){
		if ($upc == "0000000008005")
			return true;
		return false;
	}
	
	function handle($upc,$json){
		global $IS4C_PATH;
		$json['main_frame'] = $IS4C_PATH.'gui-modules/memlist.php';
		return $json;
	}
}
</pre>
<hr />
<h3>Discount Types</h3>
Calculating discounts and pricing is done based on opdata.products.discounttype.
This column is an integer, and simply hard-coding checks for a specific value is
bound to eventually conflict with another location's usage. Discount Type modules
are are a simple solution. Each store can specify an array of modules in their
configuration and opdata.products.discounttype maps into that array. Then it
doesn't matter if discounttype==4 means something different at WFC than it does
at the Wedge.
<p />
All Discount Type objects should subclass DiscountType (lib/Scanning/DiscountType.php)
and implement the following method:
<ul>
<li>priceInfo(array $row, integer $quantity) - given the $row from opdata.products,
this method should return a keyed array with four entries: regPrice, unitPrice,
discount, and memDiscount. These entries correspond with columns of the same
name in translog.localtemptrans.</li>
</ul>
There are four additional, optional methods that may be define as needed:
<ul>
<li>addDiscountLine() - if you want to add an informational "YOU SAVED" line
to the transaction, do so here.</li>
<li>isSale() - returns true if this is the discount type for "normal" pricing.
Parent version return false.</li>
<li>isMemberOnly() - returns true if the sale is only applicable to members.
Parent version return false.</li>
<li>isStaffOnly() - returns true is the sale is only applicable to staff.
Parent version return false.</li>
</ul>
<h3>Example</h3>
Here's a simple sale (see actual implementation for optional methods):
<pre>
class EveryoneSale extends DiscountType {

	function priceInfo($row, $quantity){
		$ret = array(
			'regPrice'  => $row['normal_price'],
			'unitPrice' => $row['special_price'],
			'memDiscount'  => 0
		);

		$ret['discount'] = ($ret['regPrice'] - $ret['unitPrice']) * $quantity;

		return $ret;
	}
}
</pre>
<hr />
</body>
</html>
